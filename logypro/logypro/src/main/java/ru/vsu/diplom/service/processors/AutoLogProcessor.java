package ru.vsu.diplom.service.processors;

import ru.vsu.diplom.configuration.processor.SpecificationsContainerConfiguringProcessor;
import ru.vsu.diplom.properties.SpecifierProperties;
import ru.vsu.diplom.service.logging.Logging;
import ru.vsu.diplom.service.specifier.Specifier;
import ru.vsu.diplom.service.specifier.SpecifierImpl;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.*;
import javax.lang.model.type.TypeKind;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.Writer;
import java.util.*;
import java.util.stream.Collectors;


@SupportedAnnotationTypes("ru.vsu.diplom.service.processors.AutoLog")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class AutoLogProcessor extends AbstractProcessor {

    private static final String VAR_NAME = "temp";

    private final Map<TypeElement, ClassVisitor> mVisitors = new HashMap <>();

    private Specifier specifier;
    private ProcessingEnvironment processingEnv;

    @Override
    public synchronized void init(ProcessingEnvironment env) {
//        List<String> specificationTypes = Collections.singletonList("test");
//        String packageToScan = System.getProperty("logypro.package-to-scan");
//        String connectionType = System.getProperty("logypro.connectionTypes");
        List <String> specificationTypes = Arrays.asList("test","publicFunc");
        String packageToScan = "ru.vsu.diplom";
        String connectionType = "OR";
        specifier = new SpecifierImpl(
                new SpecifierProperties(specificationTypes, connectionType),
                new SpecificationsContainerConfiguringProcessor(packageToScan));
        processingEnv = env;
        super.init(env);
    }

    @Override
    public boolean process(Set <? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        for (TypeElement annotation : annotations) {
            Set <? extends Element> annotatedElements = roundEnv.getElementsAnnotatedWith(annotation);

            List <TypeElement> matched = annotatedElements.stream()
                    .map(TypeElement.class::cast)
                    .filter(specifier::specify)
                    .collect(Collectors.toList());
            matched.forEach(x -> System.out.println(x.getSimpleName()));

            for (final TypeElement element : matched) {
                ClassVisitor visitor = mVisitors.get(element);
                if (visitor == null) {
                    visitor = new ClassVisitor(processingEnv, element);
                    mVisitors.put(element, visitor);
                }
                element.accept(visitor, null);
            }

            for (TypeElement typeElement : matched) {
                try {
                    JavaFileObject f = processingEnv.getFiler().createSourceFile(typeElement.getSimpleName() + "Autogenerated");
                    processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, "Creating " + f.toUri());
                    Writer w = f.openWriter();
                    try {
                        PrintWriter pw = new PrintWriter(w);
                        pw.println("package " + typeElement.getEnclosingElement().asType().toString() + ";");
                        pw.println("\npublic class " + typeElement.getSimpleName() + "Autogenerated" +
                                " extends " + typeElement.getSimpleName() + " {\n\n");
                        pw.println(specifier.getLogging().stream()
                                .map(l -> l.createInstanceText(typeElement.getSimpleName().toString()))
                                .collect(Collectors.joining("\n")));
                        typeElement.getEnclosedElements().forEach(x -> pw.println(printFunc((ExecutableElement) x)));
                        pw.println("}");
                        pw.flush();
                    } finally {
                        w.close();
                    }
                } catch (IOException x) {
                    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, x.toString());
                }
            }
        }
        return true;
    }

    private String printFunc(ExecutableElement element) {
        if (!specifier.specify(element)) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        sb.append(element.getModifiers().stream()
                .map(Modifier::toString)
                .collect(Collectors.joining(" ")));
        sb.append(" ");
        sb.append(element.getReturnType().toString());
        sb.append(" ");
        sb.append(element.getSimpleName());
        sb.append("(");
        sb.append(element.getParameters().stream()
                .map(x -> x.asType().toString() + " " + x.getSimpleName())
                .collect(Collectors.joining(", ")));
        sb.append(") {\n");
        sb.append(specifier.getLogging().stream()
                .map(l -> l.loggingText(
                        element.getParameters().stream()
                                .map(x -> x.getSimpleName() + ".toString()")
                                .collect(Collectors.joining(" + \", \" + "))
                ))
                .collect(Collectors.joining("\n")) + "\n");
        sb.append(superCall(element, !element.getReturnType().getKind().equals(TypeKind.VOID)));
        sb.append("\n}");
        return sb.toString();
    }

    private String superCall(ExecutableElement element, boolean isReturns) {
        StringBuilder sb = new StringBuilder();
        if (isReturns) {
            sb.append(element.getReturnType().toString() + " " + VAR_NAME + " = ");
        }
        sb.append("super." + element.getSimpleName() + "(");
        sb.append(
                element.getParameters().stream()
                        .map(VariableElement::getSimpleName)
                        .collect(Collectors.joining(", "))
        );
        sb.append(");\n");
        if (isReturns) {
            sb.append(specifier.getLogging().stream()
                    .map(l -> l.loggingText(VAR_NAME + ".toString()"))
                    .collect(Collectors.joining("\n")) + "\n");
            sb.append("return temp;");
        }
        return sb.toString();
    }
}
